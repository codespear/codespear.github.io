---
layout: post
category: programming
tags: [user interface, WTL]
excerpt: The humble file path program
---

In a previous post about the 
<a href="{% post_url 2015-02-21-model-view-presenter%}">model-view-presenter</a> I suggested a way to design a program that has a user interface.  In this post make things a bit more hands-on by exploring how we can write such a program using the Windows Template Library a.k.a. _WTL_.  This library is based on the [ATL windows classes](https://msdn.microsoft.com/en-us/library/x1wf8d3x.aspx).  It is available on [Nuget](https://www.nuget.org/packages/wtl/) or from [SourceForge](http://sourceforge.net/projects/wtl/).  

For our exploration we need a simple example problem:  For his _project_, the user wants to capture and store a list of folder names.  Every item in the list is a text string. The idea is that this text identifies a reachable folder location.  For some reason, unknown to us, he calls each folder name a _class path entry_.  

## Basic program design
Starting with cues: 
 * (C1) create a new `ClassPathEntry` for a `Project`, 
 * (C2) delete a `ClassPathEntry` and 
 * (C3) change the text of a `ClassPathEntry`.  

A quick design leads to these main view elements: 
 * (V1) a `ProjectEditView` to show the `ClassPathEntry` list,
 * (V2) an [accelerator](https://msdn.microsoft.com/en-us/library/windows/desktop/ms645526%28v=vs.85%29.aspx) item for _insert_,
 * (V3) another [accelerator] for _delete_, and 
 * (V4) a `StatusBarView` that shows how items in the `ProjectEditWindow` are selected. 

Thus, we unsurprisingly, identify these model elements: 
 * (M1) a `ClassPathEntry` 
 * (M2) a `Project` that contains a list of `ClassPathEntry` instances and 
 * (M3) a `Selection` that identifies which instances are selected. 

Let us not forget about persistence; thus we add new elements:
 * (C4) Load a `Project` when the program starts up,
 * (C5) an accelerator to save the `Project`

Not a ground breaking user experience, I know, but this program has all the interesting goodies needed for our model-view-presenter demonstration.

Our first program structure decision is about the presenter. For this simple program we need two main presenter elements. The first is called the `Application`, and it is responsible for the initial set-up of the windows.  And the other is called the `MainHandler` because it responds to the user cues. 

## The start-up sequence
According to model-view-presenter we want our presenter, the `Application` to render the first view when the application starts up.  With no [arguments](https://msdn.microsoft.com/en-us/library/chfy7caa.aspx), the initial view will show an empty `Project`.

But how do we code this start-up sequence using WTL?  I started with the WTL wizard; it created a function called `Run()` which redirects all control to a class called _CMainFrame_ (I renamed this class to `MainFrame` ).  A simple way to get `Application` wedged in here is to make `wndMain` a property of `Application`, thus getting `Run()` to call the `Application` instead.  The function invoked from `Run()` is shown below:

**Listing 1:**
{% highlight cpp %}
void Application::on_start_up(int cmd_show) {
	m_frame = new MainFrame();
	if (m_frame->CreateEx() == NULL)
		throw std::runtime_error("cannot create main window");
	m_frame->ShowWindow(cmd_show);
}
{% endhighlight %} 

The `ProjectEditWindow` is the name of the window that shows the content of the `Project` on the display device. Now we proceed to create a `ProjectEditWindow` inside `MainFrame`. Programming in WTL is a bit weird if you are used to seeing headers and a `cpp` file for every class.  Rest assured, it is OK to write all the code in `ProjectEditWindow.h`.  In fact, I renamed the view file generated by the WTL wizard.

We have the `MainFrame` creating the `ProjectEditWindow`.  Is this against the model-view-presenter ideal?  I do not think so, perhaps a container windows should be allowed to create its own children; as long as the `Application` can get to them if its needs to.  

On the model we have an empty instance of `Project` which is passed to the `Application` on start-up.  The `Project` has a function `paths()` that returns a reference to a `std::list<ClassPathEntry>`.   

To load the `Project` from a file, `Run()` receives the file name from the command line argument.  If this file does not exist, our program creates it. `Project` loads its contents into `paths()` (see this [tutorial about reading a text file](http://www.cplusplus.com/doc/tutorial/files/) if you get stuck). 

You can now get an example `Project` by saving a few lines of text to a file and passing the path to it as a command line argument to the program.  

## The view 

`ProjectEditWindow` is a rather cluttered looking piece of code - it exposes lots of implementation details. Thus, having a view element called `ProjectEditView` is a good idea to make our design intent clear. To get there we have to disentangle the code generated by the WTL wizard a bit.  The first thing we need is a new file called `ProjectEditView.h` in which we will define our new class. The view and the window are so closely coupled that I simply renamed the `ProjectEditWindow.h` file to `ProjectEditView.cpp` (Visual Studio 2013 does not like this: you also have to go to _properties_ and change the _file type_ from header to compiler).  

Model-view-presenter wants the view get the `Project` instance when it is constructed. That easy enough: add a `Project` to the constructor of `ProjectEditView`. Now change `MainFrame` to contain `ProjectEditView` (instead of `ProjectEditWindow`).  The frame now creates a window by calling `ProjectEditView::create_window(HWND)`. The `ProjectEditWindow` now keeps the reference to the `Project`, while the `ProjectEditView` keeps a reference to the `ProjectEditWindow`.  The one and only `Project` instance is passed (by reference) from the `Application` to the `MainFrame` through to the `ProjectEditWindow` via the constructors of these objects.  

## Working with the list control widget
We have the basics in place, but we are not drawing anything of interest yet.
 I want to use a list control, so I can use the WTL's wrapper class `CListViewCtrl` as the [parent class](http://en.wikipedia.org/wiki/Class_(computer_programming)).  The MFC counterpart of this control is called `CListCtrl`. Clearly, the `ProjectEditWindow` contains the WTL `CListViewCtrl` instance.

There are a few options to choose from when you want to use a WTL control in your own views; have a look at Michael Dunn's [article](http://www.codeproject.com/Articles/4028/WTL-for-MFC-Programmers-Part-IV-Dialogs-and-Contro#usingwrap) on this topic. I decided to use [CWindowImpl](https://msdn.microsoft.com/en-us/library/h4616bh2.aspx) as the base class for `ProjectEditWindow`.

On MSDN, the article about [using the CListCtrl](https://msdn.microsoft.com/en-us/library/bycfwcsh.aspx) tells you all about this control.  The list control is a sophisticated control, and a good example of a widget.  It has its own rich model and detailed events.  Wrapping this widget nicely into our model-view-presenter framework will demonstrate some of the patterns we can employ when working with widgets.

In our program, the list has a single column with an item image that indicates whether the `ClassPathEntry` exists or not . The columns and the images are added in response to [WM_SHOWWINDOW](https://msdn.microsoft.com/en-us/library/windows/desktop/ms632645%28v=vs.85%29.aspx).  For this I used:
 * the WTL implementation of [CImageList](https://msdn.microsoft.com/en-us/library/96e492b8.aspx) to set the images on the `CListViewCtrl`, and
 * the [LVITEM structure](https://msdn.microsoft.com/en-us/library/windows/desktop/bb774760%28v=vs.85%29.aspx) to create the list items.

We want the status-bar to update when the user selects items.  The code-project [article about bars](http://www.codeproject.com/Articles/3948/WTL-for-MFC-Programmers-Part-III-Toolbars-and-Stat) provides a good overview and using the same pattern now established we end up with a `StatusBarView`.  This view element listens to `Selection` and redraws the status bar when the selection changes. 

When the user clicks on the `ProjectEditWindow` a [LVN_ITEMCHANGED notification](https://msdn.microsoft.com/en-us/library/windows/desktop/bb774845.aspxs) is sent to the parent window.  So, by default, it is the code in the `MainFrame` that can update the `Selection`. There are two possible improvements: (1) keep the response to selection local to `ProjectEditWindow` by using [message reflection](https://msdn.microsoft.com/en-us/library/aa260759.aspx#atlwindow_topic11) or (2) message chaining. 

In particular, the [CHAIN_MSG_MAP_MEMBER](https://msdn.microsoft.com/en-us/library/ttz68kw1.aspx) provides a neat method we can use to get closer to the model-view-presenter pattern. We create a class called `MainHandler`; pass an instance of it to `MainFrame` (via `Application`) and get `Mainframe` to chain messages to the `MainHandler`.  Using this technique we can get all the handling code out of the view elements, into the presenter's space.  

## Responding to cues
Keeping things simple, we listen for VK_DELETE on [WM_KEYDOWN](https://msdn.microsoft.com/en-us/library/windows/desktop/ms646280%28v=vs.85%29.aspx)
Now for a delete function.  For this we listen for [LVN_DELETEITEM](https://msdn.microsoft.com/en-us/library/windows/desktop/bb774812.aspx) in the `ProjectEditWindow`.  Then we send a WM_COMMAND called ID_EDIT_DELETE to `MainHandler`.  `MainHandler` asks the user if it is OK to delete, and if it is the `Project` is modified.  The `ProjectEditWindow` observes the `Project` and removes the deleted element when it receives an event. The other cues form the same general pattern.  

A response to a cue does not require a command, but I decided the model-view-presenter is not complete without it.  So `MainHandler` instantiates and executes a `ProjectCommand`.  The `Project` itself is the factory for the concrete commands: `DeleteCommand`, `InsertCommand` and `EditCommand`.   
